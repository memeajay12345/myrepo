import pandas as pd
import calendar
from datetime import datetime, timedelta
import requests
import time
import fnmatch
import os

masterfile_path = r'C:\Users\U544750\Documents\Usecases\EDW_conrolm\edw_ctm_masterfile.csv'
not_triggered_csv = r"C:\Users\U544750\Documents\Usecases\EDW_conrolm\long_running.csv"

current_hour = int(datetime.now().hour)
if current_hour == 1:
    if os.path.exists(not_triggered_csv):
        os.remove(not_triggered_csv)

#read master file data
master_df = pd.read_csv(masterfile_path, dtype=str)
today = datetime.today()
weekday_name = today.strftime("%A")
#print(master_df)
print(f"day : {weekday_name}")

def get_business_day(year, month):
    total_days = calendar.monthrange(year, month)[1]
    return [
        datetime(year, month, day) for day in range(1, total_days + 1) if datetime(year, month, day).weekday() < 5
    ]
business_days = get_business_day(today.year, today.month)
#print(business_days)

business_day_position = None
for idx, bday in enumerate(business_days):
    if bday.date() == today.date():
        business_day_position = idx + 1
        break
is_last_bday = today.date() == business_days[-1].date()

run_dates = [weekday_name]
if business_day_position == 1:
    run_dates.append("first")
elif business_day_position == 2:
    run_dates.append("second")
elif business_day_position == 3:
    run_dates.append("third")
if is_last_bday:
    run_dates.append("last")

#fetch jobs
filtered_df = master_df[master_df["Run Date"].str.lower().isin([v.lower() for v in run_dates])]
filtered_df = filtered_df.copy()
filtered_df["Start Time"] = pd.to_datetime(filtered_df["Start Time"], format='%I:%M %p').dt.time

#current time and last 30 min time
now1 = datetime.now().replace(second=0, microsecond=0)
last_thirty_min = now1 - timedelta(minutes=30)
current_time = now1.time()
cutoff_time = last_thirty_min.time()
recent_jobs = filtered_df[(filtered_df["Start Time"] >= cutoff_time) & (filtered_df["Start Time"] <= current_time)]
filtered_dict = recent_jobs[["Job", "Run Time"]].to_dict("records")

#fetch long running and not triggered jobs
long_running = []
not_triggered = []
api_headers = []
url = f"https://controlm.fyiblue.com/automation-api/run/jobs/status?folder=DASI@PRD"
retry_count = 0

while True:
    try:
        response = requests.get(url, headers=api_headers, verify=False)
        if response.status_code == 200:
            break
        else:
            retry_count += 1
    except Exception as e:
        retry_count += 1
    time.sleep(2)
    
data = response.json().get("statuses", [])

for pattern_row in filtered_dict:
    pattern = pattern_row['Job']
    allowed_min = int(pattern_row['Run Time'])
    found = False
    for d in data:
        job_name = d.get("name")
        start_time = d.get("startTime")
        status = d.get("status")
        if fnmatch.fnmatch(job_name, pattern) and status == "Executing":
            found = True

        try:
            now = datetime.now()
            start_fmt = datetime.strptime(start_time, "%Y%m%d%H%M%S")
            start_fmt1 = datetime.strptime(start_time, "%Y%m%d%H%M%S").strftime("%m/%d/%Y %I:%M:%S %p") if start_time else ""
            diff_min = int((now - start_fmt).total_seconds() // 60)
        except Exception as e:
            continue
            
        if diff_min > allowed_min:
            long_running.append({
                "Job Name" : job_name,
                "Start Time" : start_fmt1,
                "End Time" : "",
                "Status" : status
            })
        break

    if not found:
        not_triggered.append({
            "Job Name" : pattern,
            "Run Time" : allowed_min
        })

if long_running:
    result_df1 = pd.DataFrame(long_running)

if not_triggered:
    result_df2 = pd.DataFrame(not_triggered)
    result_df2.to_csv(not_triggered_csv, index=False)
